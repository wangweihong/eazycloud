package main_test

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"go/types"
	"log"
	"os"
	"strings"
	"testing"
)

var srcCode = `
package hello

import(
	"package_a"
	pb "package_b"
)

type MyStruct struct{
	A string 
	B int
	C bool
	d string
	e int
	f bool
 	
	PA pb.A
}
`

var basicTypes = map[string]string{
	"bool":       "false",
	"uint":       "0",
	"uint8":      "0",
	"uint16":     "0",
	"uint32":     "0",
	"uint64":     "0",
	"int":        "0",
	"int8":       "0",
	"int16":      "0",
	"int32":      "0",
	"int64":      "0",
	"uintptr":    "0",
	"float32":    "0",
	"float64":    "0",
	"string":     "\"\"",
	"complex64":  "0",
	"complex128": "0",
	"byte":       "nil",
	"rune":       "nil",
	// builtin golang objects
	"time.Time":       "{}",
	"json.RawMessage": "nil",
}

func getBasicTypeDefault(Type string) string {
	if r, ok := basicTypes[Type]; ok {
		return r
	}
	log.Println("unknown type:",Type)
	return "nil"
}
func TestAST(t *testing.T){

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, "", srcCode, 0)
	if err != nil {
		t.Fatal(err)

	}
	g := Generator{}

	imports:= f.Imports
	g.imports= append(g.imports,imports...)

	if f.Name != nil {
		g.packageName = f.Name.Name
	}
	//ast.Print(fset, f)
	for _,d:= range f.Decls{
		switch specDecl:=d.(type){
		case *ast.FuncDecl:
			// do nothing
		case *ast.GenDecl: // 通用声明，包含静态定义，结构定义等
			switch specDecl.Tok{
			case token.TYPE:
				for _,s:=range specDecl.Specs{
					t := s.(*ast.TypeSpec)
					if t.Name == nil || t.Name.Name == "" {
						continue
					}
					switch tp:=t.Type.(type){
					case *ast.StructType:
						g.structType = append(g.structType,&StructType{
							name: t.Name.Name,
							structType: tp,
						})
					case *ast.ArrayType:
					case *ast.Ident:
					default:

					}
				}
				fmt.Println("Its type")
			case token.STRUCT:
				fmt.Println("Its struct")
			default:
				fmt.Println(specDecl.Tok)
			}

		}
	}
	g.generate()
	str := g.format()
	fmt.Println(string(str))
}

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf bytes.Buffer // Accumulated output.
	//pkg *Package     // Package we are scanning.
	packageName string
	imports  []*ast.ImportSpec //import列表
	structType []*StructType //结构类型定义列表
}

type StructType struct {
	name string
	structType *ast.StructType //结构类型定义列表
}

// File holds a single parsed file and associated data.
type File struct {
	pkg  *Package  // Package to which this file belongs.
	file *ast.File // Parsed AST.
}

// Package defines options for package.
type Package struct {
	name  string
	defs  map[*ast.Ident]types.Object
	files []*File
}

// Printf like fmt.Printf, but add the string to g.buf.
func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// 生成go代码.
func  (g *Generator)generate() {
	//values := make([]Value, 0, 500)
	//for _, file := range g.pkg.files {
	//	// Set the state for this run of the walker.
	//	if file.file != nil {
	//		ast.Inspect(file.file, file.genDecl)
	//		//values = append(values, file.values...)
	//	}
	//}

	// Print the header and package clause.
	g.Printf("// Code generated by \"fieldgen %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
	g.Printf("\n")
	g.Printf("package %s", g.packageName)
	g.Printf("\n")

	for _,v:= range g.structType{
		for _,f:=range v.structType.Fields.List{
			if len(f.Names) == 0 {
				continue
			}
			g.Printf("func (m *%s)Get%s()%s{\n",v.name,f.Names[0].Name,fmt.Sprint(f.Type))
			g.Printf("if m != nil {\n")
			g.Printf("return m.%v\n",f.Names[0].Name)
			g.Printf("}\n")
			g.Printf("\n")
			switch f.Type.(type) {
			case *ast.ArrayType,
				*ast.StarExpr,
				*ast.MapType,
				*ast.InterfaceType:
					g.Printf("return nil\n")
			default:
				g.Printf("return %s\n",getBasicTypeDefault(fmt.Sprint(f.Type)))
			}
			g.Printf("}\n")
			g.Printf("\n")
		}
		}

	g.Printf("\n")
	// Generate code that will fail if the constants change value.

}


// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")

		return g.buf.Bytes()
	}

	return src
}
//
//// addPackage adds a type checked Package and its syntax files to the generator.
//func (g *Generator) addPackage(pkg *packages.Package) {
//	g.pkg = &Package{
//		name:  pkg.Name,
//		defs:  pkg.TypesInfo.Defs,
//		files: make([]*File, len(pkg.Syntax)),
//	}
//
//	for i, file := range pkg.Syntax {
//		g.pkg.files[i] = &File{
//			file:       file,
//			pkg:        g.pkg,
//		}
//	}
//}
//
//
//func (f *File) genDecl(node ast.Node) bool {
//	// 通用声明,包括IMPORT,VAR,CONST,TYPE
//	decl, ok := node.(*ast.GenDecl)
//	if !ok || decl.Tok != token.TYPE {
//		// We only care about type declarations.
//		return true
//	}
//
//
//	return false
//}
